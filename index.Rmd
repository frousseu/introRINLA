---
title: "Introduction aux modèles spatiaux avec R-INLA"
author: <span style="color:black">François Rousseu</span>
date: <span style="color:black">3 mai 2018</span>
output:
  html_document:
    depth: 5
    fig_height: 5
    fig_width: 6
    number_sections: no
    code_folding: show
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: no
      smooth_scroll: no
---

<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 20, 'padding-left': 2, 'padding-bottom': 0, 'padding-top': 0, 'padding-right': 2});
      });

    });
</script>


<style>

pre.r {
    background-color: #CCCCCC!important;
    border-color: #EEEEEE!important;
    font-size: 14pt;
}

pre code {
  font-size: 11pt;
}

body {
  font-size: 14pt;
  /*background-color: lightblue;*/
}

.main-container {
    max-width: 1300px !important;
    /*background-color: lightblue;*/
}

#TOC {
  font-size: 12pt;
  border-color: white;
}

.list-group-item.active:focus{
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

.list-group-item.active:hover {
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

.list-group-item.active{
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

h1.title {
  margin-top: 120px;
  font-size: 42px;
  color: DarkGreen;
  font-weight: bold;
}
h1 {
  padding-top: 50px;
  font-size: 42px;
  color: DarkGreen;
  font-weight: bold;
}
h2 {
  padding-top: 50px;
  font-size: 36px;
  color: DarkGreen;
  font-weight: bold;
}

h3 {
  padding-top: 10px;
  font-size: 32px;
  color: DarkGreen;
  font-weight: bold;
}
h4 {
  font-size: 28px;
  color: DarkGreen;
  font-weight: bold;
}
h5 {
  font-size: 26px;
  color: DarkGreen;
  font-weight: bold;
}

hr {
    border: none;
    height: 10px;
    /* Set the hr color */
    color: grey; /* old IE */
    background-color: grey; /* Modern Browsers */
}

</style>

```{r setup, include=TRUE, echo=FALSE}
knitr::opts_chunk$set(echo=TRUE,cache=TRUE,tidy=TRUE,error=TRUE,message=FALSE,warning=FALSE,fig.align="center",collapse=FALSE)
```

<br>

# Introduction

<hr>

## Types de données

Il y a 3 principaux types de données spatiales

- Données géostatistiques
- Données de points (point pattern)
- Données d'aires (areal data or lattice data

<hr>

### Données géostatistiques

**Ce sont des données mesurées à des points fixes dans l'espace**

- Aussi connu sous le nom de géostatistiques, kriging.

<center>
```{r,cache=TRUE,echo=FALSE}

library(weathercan)
library(raster)
library(scales)

s<-stations[stations$prov=="QC",]
can<-getData("GADM",country="CAN",level=1)
qc<-can[can$NAME_1=="Québec",]

par(mar=c(0,0,0,0))
plot(qc,col="grey80",border=NA)
points(s$lon,s$lat,pch=16,col="darkred",cex=0.5)
legend("topright",pch=16,col="darkred",pt.cex=0.5,legend="Station météo",bty="n",cex=1)

```
</center>
<br>
Données récoltées à des stations météo

<img src="https://raw.githubusercontent.com/frousseu/introRINLA/master/Rlogo.png" alt="", width = "4%">
[geoR](http://www.leg.ufpr.br/geoR/), [gstat](https://r-spatial.github.io/gstat/), [nlme](https://CRAN.R-project.org/package=nlme), [glmmTMB](https://cran.r-project.org/web/packages/glmmTMB/vignettes/covstruct.html), [R-INLA](http://www.r-inla.org/)


<hr>

### Point pattern

**Ce sont des données où la localisation des points dans l'espace est aléatoire**

<center>
```{r,cache=TRUE,echo=FALSE}

library(rgbif)
o<-occ_search(scientificName="Phragmites australis",limit=5000,publishingCountry="CA",stateProvince="Québec",hasCoordinate=TRUE)

par(mar=c(0,0,0,0))
plot(qc,col="grey80",border=NA,ylim=c(46,50))
points(o$data$decimalLongitude,o$data$decimalLatitude,pch=16,col=alpha("darkgreen",0.3),cex=0.5)
legend("topright",pch=16,col=alpha("darkgreen",0.3),pt.cex=0.5,legend="Mention de Phragmite",bty="n",cex=1)

```
</center>
<br>
L'ensemble des mentions d'occurrence pour la Phragmite commune (*Phragmites autralis*)

<img src="https://raw.githubusercontent.com/frousseu/introRINLA/master/Rlogo.png" alt="Upside-down sloths are so cute", width = "4%">
[spatstat](http://spatstat.org/), [R-INLA](http://www.r-inla.org/)

<hr>

### Areal data

**Ce sont des données qui sont agrégées au niveau d'entités surfaciques**

<center>
```{r,out.width="40%",cache=TRUE,echo=FALSE}
s<-stations[stations$prov=="QC",]
can<-getData("GADM",country="CAN",level=2)
qc<-can[can$NAME_1=="Québec",]

par(mar=c(0,0,0,0))
plot(qc,col="grey80",border="white",ylim=c(45,50),lwd=0.1)
```
</center>
<br>
Nombre de cas de détection de virus du Nil par unités administratives

<img src="https://raw.githubusercontent.com/frousseu/introRINLA/master/Rlogo.png" alt="Upside-down sloths are so cute", width = "4%">
[spdep](https://r-spatial.github.io/spdep/), [R-INLA](http://www.r-inla.org/)

<hr>

###

## Variogrammes

Différentes valeurs de paramètres

<hr>

### Empirical variogram

Intuitivement, c'est la variance des différences entre toutes les paires d'observations pour différentes classe de distances.

(mean square difference between each pair of variable divided by 2, semi-variance)

<hr>

### Theoretical variogram

Ce sont les modèles qui sont ajustés au variogramme empirique.

```{r,warning=FALSE}
library(gstat)
show.vgms(models=c("Exp","Gau","Sph","Cir"),nugget=0,as.groups=TRUE)
```

Différents types de fonctions

<hr>

```{r,warning=FALSE}
show.vgms(kappa.range=c(0.5,1,2,5),models="Mat",max=10,as.groups=TRUE)
```

<hr>

```{r}
# https://doi.org/10.5061/dryad.7sk2g/1

d<-read.csv("C:/Users/User/Downloads/Irl et al_2015_J Ecol_Dryad.csv",skip=1,sep=";",dec=",")
names(d)<-gsub("\\.","",names(d))
d$northing<-d$LongitudeUTM/1000
d$easting<-d$LatitudeUTM/1000
d$Elevationm<-d$Elevationm/1000
plot(d[,c("SR","Elevationm","TCI")])

```



<hr>

```{r,out.width="100%"}
library(sp)
library(mapview)
coordinates(d)<-~easting+northing
proj4string(d)<-"+proj=utm +zone=28 +ellps=WGS84 +datum=WGS84 +units=km +no_defs"
ds<-spTransform(d,CRS("+init=epsg:4326"))
mapviewOptions(basemaps = c("Esri.WorldImagery","Esri.WorldShadedRelief"))
mapview(ds,zcol="SR")
```

<hr>

```{r}
# https://doi.org/10.5061/dryad.7sk2g/1

library(scales)
spa<-getData("GADM",country="ESP",level=2)
laspalmas<-disaggregate(spa)[225,]

plot(laspalmas,axes=TRUE)
plot(ds,add=TRUE,col=alpha("darkgreen",0.5),pch=16)

```




<hr>

```{r}
fit<-glm(SR~Elevationm+I(Elevationm^2)+TCI,data=d@data,family=poisson)
summary(fit)
```

<hr>

```{r}
library(visreg)
par(mfrow=c(1,2))
visreg(fit,scale="response",rug=FALSE)
```

<hr>

```{r}
library(geoR)
v<-variog(coords=cbind(d$easting,d$northing),data=resid(fit),breaks=seq(0,10,by=0.5),max.dist=10)
plot(v, main="Empirical Variogram for Species Richness (SR)",type="b",xlab="Distance (km)",ylab="Semivariance") 
```

<hr>

## INLA

### Approche bayésienne

<hr>

Bayes' rule

$$P(A|B) = \frac{P(B|A)P(A)}{P(B)}$$

<hr>

Lorsque appliquée aux modèles

$$P(\theta|data) = \frac{P(data|\theta)P(\theta)}{P(data)}$$
<br><br>
$data$: données
$\theta$: paramètres du modèle

### Priors

### LGM

### SPDE

SPDE veut dire **S**tochastic **P**artial **D**ifferential **E**quation

Cette approche se base entre-autres sur une discrétisation du Gaussian Random Field (GRF) par un Gaussian Markov Random Field (GMRF)

Utilise une fonction de Matérn pour capturer la dépendance entre les localisations.


<hr>

<!--
<figure>
<img src="C:/Users/User/Documents/GitHub/introRINLA/approachSPDE_Zuur.jpg" alt="", width = "100%">
<figcaption>Tiré de <a href="http://highstat.com/index.php/beginner-s-guide-to-regression-models-with-spatial-and-temporal-correlation" target="_blank">Zuur, Ieno et Saveliev (2017)</a>, Volume I</figcaption>
</figure>
-->

##

```{r}
library(INLA)
m<-inla(SR~Elevationm+I(Elevationm^2)+TCI,data=d@data,family="poisson")
summary(m)
```

<hr>

```{r}
m$summary.fixed[,c(1:3,5)]
cbind(summary(fit)$coef[,1:2],confint(fit))
```



# Un exemple de cas

## Cas

## Étapes

L'estimation d'un modèle avec un effet spatial avec INLA requiert de passer par plusieurs étapes.

- **Mesh**: permet de créer une triangulation qui discrétise le GF
- **Projector Matrix**: permet de relier les localisations à la grille
- **SPDE**: permet détablir le lien le SPDE et la fonction Matérn
- **Spatial Field**: permet de créer le champs spatial
- **Stack**: permet d'intégrer les différents éléments
- **Formula**: formulation du modèle
- **Modèle**: permet de faire tourner le modèle

<hr>

Voici un résumé graphique de ces différentes étapes avec les fonction associées.

<!--
<figure>
<img src="C:/Users/User/Documents/GitHub/introRINLA/stepsSPDE_Zuur.jpg" alt="", width = "100%">
<figcaption>Tiré de <a href="http://highstat.com/index.php/beginner-s-guide-to-regression-models-with-spatial-and-temporal-correlation" target="_blank">Zuur, Ieno et Saveliev (2017)</a>, Volume I</figcaption>
</figure>
-->

<hr>

### Mesh

La première étape consiste à créer une grille (*mesh*) qui va être utilisée pour approximer le champs Gaussien. En premier, il faut obtenir les localisations.

```{r,collapse=FALSE}
locs<-coordinates(d)
head(locs)
```

<hr>

Par la suite, on utilise la fonction `inla.mesh.2d` pour créer la grille. Optionnellement, on peut utiliser une grille non-convexe qui respecte davantage le contour de nos observations.

```{r,collapse=FALSE}
library(INLA)
hull<-inla.nonconvex.hull(locs,convex=-0.05)
mesh<-inla.mesh.2d(loc=locs,offset=c(1,5),max.edge=c(1,3),cutoff=1,boundary=hull)
```

<hr>

```{r,collapse=FALSE,fig.width=8,fig.height=8}
par(mar=c(0,0,6,0))
plot(mesh,asp=1)
points(locs,col=alpha("red",0.6),pch=16,cex=0.7)
```


<hr>

`offset` 
<br>
<br>
Spécifie l'étendue de l'extension de la grille au delà des observations et l'extension d'une zone tampon au-delà de cette grille. Cette dernière permet de réduire les effets de bordure lors des estimations. L'étendue de cette zone tampon doit être **au moins aussi grande que l'étendue de la corrélation spatiale**.

`max.edge` 
<br>
<br>
Permet de spécifier les dimensions maximales des triangles de la grille à l'intérieur et à l'extérieur dans la zone tampon. Plus ces triangles sont petits, plus les approximations sont précises, mais plus les calculs sont longs. En général, il n'est pas nécessaire que les triangles dans la zone tampon soient aussi petit qu'à l'intérieur de la grille.

`cutoff`
<br>
<br>
Par défaut, chaque observation sera utilisée comme un coin d'un triangle. Pour éviter la création de trop nombreux petit triangles, on spécifie une valeur à `cutoff` au0delà de laquelle des points voisins seront ignorés lors de la création des triangles.

`boundary`
<br>
<br>
Cet argument permet d'utilier l'étendue non-convexe autour des observations.

Il faut éviter d'avoir des triangles avec des aigles trop aigus. Autrement, les estimations sont de moins bonnes qualité.

<hr>


### Projector Matrix

```{r,collapse=FALSE}
A<-inla.spde.make.A(mesh,locs)
```

<hr>

### SPDE

```{r,collapse=FALSE}
prior.sd<-10
prior.range<-1
spde<-inla.spde2.pcmatern(mesh,alpha=2,prior.range=c(prior.range,0.5),prior.sigma=c(prior.sd,0.01))
```

<hr>

### Spatial Field

```{r,collapse=FALSE}
s.index<-inla.spde.make.index(name="spatial",n.spde=spde$n.spde)
```

<hr>

### Stack

```{r,collapse=FALSE}
d$Elevationm2<-d$Elevationm^2
v<-c("TCI","Elevationm","Elevationm2")
vars<-d@data[,v]
stack<-inla.stack(data=list(SR=d$SR),A=list(A,1),effects=list(c(s.index,list(Intercept=1)),as.list(vars)),tag="est")
```

<hr>

### Formula

```{r,collapse=FALSE}
model<-SR~-1+Intercept+Elevationm+Elevationm2+TCI+f(spatial,model=spde)
```

<hr>

### Modèle

```{r,collapse=FALSE}
m<-inla(model,data=inla.stack.data(stack),control.predictor=list(A=inla.stack.A(stack)),control.compute=list(dic=TRUE,waic=TRUE,config=TRUE),control.inla=list(int.strategy="eb"),family="poisson")
```

<hr>

## Extraction 

<hr>

### Summary

```{r,collapse=FALSE}
summary(m)
```

<hr>

#### Distributions postérieures

```{r,collapse=FALSE}
par(mfrow=c(2,2))
invisible(
	 lapply(names(m$marginals.fixed),function(i){
    p<-m$marginals.fixed[[i]]	
	   plot(p[,1],p[,2],type="l",xlab=i,ylab="density")
	   abline(v=0,lty=3)
  })
)
```

<hr>

### Paramètres spatiaux

```{r,collapse=FALSE}
res<-inla.spde.result(m,"spatial",spde)
par(mfrow=c(2,1))
plot(res$marginals.range.nominal[[1]],
     type="l", main="Posterior density for range")
plot(inla.tmarginal(sqrt, res$marginals.variance.nominal[[1]]),
     type="l", main="Posterior density for sd")
```

<hr>

```{r,include=FALSE,echo=FALSE}
#tmp = inla.tmarginal(function(x) exp(-x), m$internal.marginals.hyperpar[[2]]) 
#xvals = seq(0, 10, length.out=1000)
#plot(tmp, type = "l", xlab = "inverse range", ylab = "Density",xlim=range(xvals))
#lambda = -log(.5)/(1/prior.median.range); lines(xvals, 6*exp(-lambda*xvals), lty='dashed')
```

```{r,echo=FALSE,include=FALSE}
#library(inlabru)
#spde.posterior(m,"spatial",what="range")
```

<hr>

### Visualisations du champ spatial

```{r,collapse=FALSE}

library(fields)
library(viridisLite)

# https://haakonbakka.bitbucket.io/btopic108.html#92_plotting_the_spatial_mean_field


xlim<-range(d$easting)
ylim<-range(d$northing)

# - Can project from the mesh onto a 300x300 plotting grid 
proj<-inla.mesh.projector(mesh,xlim=xlim,ylim=ylim,dims=c(300,300))

# - Do the projection
field<-m$summary.random[['spatial']][['mean']]
field.proj<-inla.mesh.project(projector=proj,field=field)


par(mar=c(2,2,2,2))
image.plot(list(x=proj$x,y=proj$y,z=field.proj),col=viridis(100),asp=1)  
axis(1)
axis(2)

```

<hr>

#### Champ moyen

<hr>
#### Champ sd

<hr>
## Prédictions


<hr>

`control.compute=list(config=TRUE)`

```{r,collapse=FALSE,include=FALSE,eval=FALSE}
m<-inla(model,data=inla.stack.data(stack),control.predictor=list(A=inla.stack.A(stack)),control.compute=list(config=TRUE),control.inla=list(int.strategy="eb"),family="poisson")
```

<hr>

```{r,collapse=FALSE,include=FALSE,eval=FALSE}

nsims<-100
sims<-inla.posterior.sample(n=nsims,result=m,seed=123)

v<-m$names.fixed
v 

post<-lapply(v,function(i){
	 g<-match(i,row.names(sims[[1]]$latent))
	 do.call(c,lapply(sims,function(i){i$latent[g,1]}))
})
names(post)<-v


par(mfrow=c(2,2))
invisible(
	 lapply(names(post),function(i){
    p<-post[[i]]	
	   hist(p,xlab=i,ylab="density",main="")
	   abline(v=0,lty=3)
  })
)

index<-grep("spatial:",row.names(sims[[1]]$latent))

w<-lapply(sims,function(i){
	 i$latent[index]
})
w<-do.call(cbind,w)
#names(post)<-vars

ysims<-lapply(1:nsims,function(i){
	 betas<-sapply(post,"[",i)
  mm<-as.matrix(cbind(Intercept=1,vars))
	 fixed<-mm %*% betas
	 spatial<-as.matrix(A) %*% w[,i]
	 mu<-exp(fixed+spatial)
	 ysim<-rpois(nrow(d),lambda=mu)
	 ysim
})

plot(density(d$SR),col="red",lwd=2)
lapply(ysims,function(i){
  lines(density(i),col=gray(0,0.05))	
})




```











```{r, include=FALSE,eval=FALSE}
library(scales)
d<-read.table("C:/Users/User/Downloads/IrishPh/IrishPh.txt",header=TRUE)

d$Easting<-d$Easting/1000
d$Northing<-d$Northing/1000
d$Forested<-as.factor(d$Forested)

hist(d$pH)
plot(d$Easting,d$Northing,cex=rescale(d$pH,to=c(0,2)))


fit<-glm(pH~SDI+Altitude+Forested,data=d)
summary(fit)

library(visreg)
par(mfrow=c(1,2))
visreg(fit,scale="response",rug=FALSE)


library(geoR)
v<-variog(coords=cbind(d$Easting,d$Northing),data=resid(fit),breaks=seq(0,100,by=5),max.dist=100)
plot(v, main="Empirical Variogram for Species Richness (SR)",type="b",xlab="Distance (km)",ylab="Semivariance") 




d<-read.csv("https://raw.githubusercontent.com/frousseu/ECL749/master/data/frogs.csv",sep=";")
d$easting<-jitter(d$easting)
d$northing<-jitter(d$northing)

plot(d$easting,d$northing,col=d$pres.abs+1,asp=1)

fit<-glm(pres.abs~NoOfPools,family="binomial",data=d)

v<-variog(coords=cbind(d$easting,d$northing),data=resid(fit),max.dist=500,breaks=seq(0,500,by=15))#,breaks=seq(0,20,by=1),max.dist=20)
plot(v, main="Empirical Variogram for Species Richness (SR)",type="b",xlab="Distance (km)",ylab="Semivariance") 


# https://doi.org/10.5061/dryad.c2378/2

library(sp)
d<-read.csv("C:/Users/User/Downloads/presabs_both_IndYears_allvars_final.csv")
coordinates(d)<-~BCAlbX+BCAlbY
plot(d,pch=ifelse(d$pres==0,1,16)
					
fit<-glm(pres~Elevation+CTI,family="binomial",data=d)
v<-variog(coords=coordinates(d),data=resid(fit),breaks=seq(0,10000,by=500),max.dist=10000)
plot(v, main="Empirical Variogram for Species Richness (SR)",type="b",xlab="Distance (km)",ylab="Semivariance") 


```









# Exercice 1

# Exercice 2

# Liens utiles

## Forum R-INLA

## Livres en ligne

## Livres

## Articles importants

---

Select the menu on the left to expand / collapse table of contents (TOC)
entries. Press button below to collapse all TOC except the top level headings.

<button id="btnCollapseHeading" onclick="collapseTOC()">Collapse sub-headings</button>

If you only want to collapse level 3 headings press this button.

<button id="btnCollapseLevel3" onclick="collapseLevel3()">Collapse Level 3 only</button>

<script>
function collapseTOC() {
  var x = document.getElementsByClassName("tocify-subheader");
  var i;
  for (i = 0; i < x.length; i++) {
      x[i].style.display = "none";
  }
}

function collapseLevel3() {
  var x = document.getElementsByClassName("tocify-subheader");
  var i;
  for (i = 0; i < x.length; i++) {
      if (x[i].getAttribute("data-tag") == "3") {
        x[i].style.display = "none";
      }
  }
}

</script>

