---
title: "Introduction aux modèles spatiaux avec R-INLA"
author: <span style="color:black">François Rousseu</span>
date: <span style="color:black">3 mai 2018</span>
output:
  html_document:
    depth: 4
    fig_height: 5
    fig_width: 6
    number_sections: no
    code_folding: show
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: yes
      smooth_scroll: no
---

<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 20, 'padding-left': 0});
      });

    });
</script>


<style>

pre.r {
    background-color: #CCCCCC!important;
    border-color: #EEEEEE!important;
    font-size: 14pt;
}

pre code {
  font-size: 11pt;
}

body {
  font-size: 14pt;
}

.main-container {
    max-width: 1300px !important;
}

#TOC {
  font-size: 12pt;
  border-color: white;
}

.list-group-item.active:focus{
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

.list-group-item.active:hover {
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

.list-group-item.active{
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

h1.title {
  margin-top: 120px;
  font-size: 42px;
  color: DarkGreen;
  font-weight: bold;
}
h1 {
  padding-top: 50px;
  font-size: 42px;
  color: DarkGreen;
  font-weight: bold;
}
h2 {
  padding-top: 50px;
  font-size: 36px;
  color: DarkGreen;
  font-weight: bold;
}

h3 {
  padding-top: 10px;
  font-size: 32px;
  color: DarkGreen;
  font-weight: bold;
}
h4 {
  font-size: 28px;
  color: DarkGreen;
  font-weight: bold;
}
h5 {
  font-size: 26px;
  color: DarkGreen;
  font-weight: bold;
}

</style>

```{r setup, include=TRUE, echo=FALSE}
knitr::opts_chunk$set(echo=TRUE,cache=TRUE,tidy=TRUE,error=TRUE,message=FALSE,warning=FALSE,fig.align="center",collapse=FALSE)
```

<br>

# Introduction

****

## Types de données

Il y a 3 principaux types de données spatiales

- Données géostatistiques
- Données de points (point pattern)
- Données d'aires (areal data or lattice data

****

### Données géostatistiques

**Ce sont des données mesurées à des points fixes dans l'espace**

- Aussi connu sous le nom de géostatistiques, kriging.

<center>
```{r,fig.width=4,fig.height=4,cache=TRUE,echo=FALSE}

library(weathercan)
library(raster)
library(scales)

s<-stations[stations$prov=="QC",]
can<-getData("GADM",country="CAN",level=1)
qc<-can[can$NAME_1=="Québec",]

par(mar=c(0,0,0,0))
plot(qc,col="grey80",border=NA)
points(s$lon,s$lat,pch=16,col="darkred",cex=0.5)
legend("topright",pch=16,col="darkred",pt.cex=0.5,legend="Station météo",bty="n",cex=1)

```
</center>
<br>
Données récoltées à des stations météo

<img src="https://raw.githubusercontent.com/frousseu/introRINLA/master/Rlogo.png" alt="Upside-down sloths are so cute", width = "4%">
[geoR](http://www.leg.ufpr.br/geoR/), [gstat](https://r-spatial.github.io/gstat/), [nlme](https://CRAN.R-project.org/package=nlme), [glmmTMB](https://cran.r-project.org/web/packages/glmmTMB/vignettes/covstruct.html), [R-INLA](http://www.r-inla.org/)


****

### Point pattern

**Ce sont des données où la localisation des points dans l'espace est aléatoire**

<center>
```{r,fig.width=4,fig.height=4,cache=TRUE,echo=FALSE}

library(rgbif)
o<-occ_search(scientificName="Phragmites australis",limit=5000,publishingCountry="CA",stateProvince="Québec",hasCoordinate=TRUE)

par(mar=c(0,0,0,0))
plot(qc,col="grey80",border=NA,ylim=c(46,50))
points(o$data$decimalLongitude,o$data$decimalLatitude,pch=16,col=alpha("darkgreen",0.3),cex=0.5)
legend("topright",pch=16,col=alpha("darkgreen",0.3),pt.cex=0.5,legend="Mention de Phragmite",bty="n",cex=1)

```
</center>
<br>
L'ensemble des mentions d'occurrence pour la Phragmite commune (*Phragmites autralis*)

<img src="https://raw.githubusercontent.com/frousseu/introRINLA/master/Rlogo.png" alt="Upside-down sloths are so cute", width = "4%">
[spatstat](http://spatstat.org/), [R-INLA](http://www.r-inla.org/)

****

### Areal data

**Ce sont des données qui sont agrégées au niveau d'entités surfaciques**

<center>
```{r,out.width="40%",cache=TRUE,echo=FALSE}
s<-stations[stations$prov=="QC",]
can<-getData("GADM",country="CAN",level=2)
qc<-can[can$NAME_1=="Québec",]

par(mar=c(0,0,0,0))
plot(qc,col="grey80",border="white",ylim=c(45,50),lwd=0.1)
```
</center>
<br>
Nombre de cas de détection de virus du Nil par unités administratives

<img src="https://raw.githubusercontent.com/frousseu/introRINLA/master/Rlogo.png" alt="Upside-down sloths are so cute", width = "4%">
[spdep](https://r-spatial.github.io/spdep/), [R-INLA](http://www.r-inla.org/)

****

###

## Variogrammes

Différentes valeurs de paramètres

****

### Empirical variogram

Intuitivement, c'est la variance des différences entre toutes les paires d'observations pour différentes classe de distances.

(mean square difference between each pair of variable divided by 2, semi-variance)

****

### Theoretical variogram

Ce sont les modèles qui sont ajustés au variogramme empirique.

```{r,warning=FALSE}
library(gstat)
show.vgms(models=c("Exp","Gau","Sph","Cir"),nugget=0,as.groups=TRUE)
```

Différents types de fonctions

****

```{r,warning=FALSE}
show.vgms(kappa.range=c(0.5,1,2,5),models="Mat",max=10,as.groups=TRUE)
```

****

```{r}
# https://doi.org/10.5061/dryad.7sk2g/1

d<-read.csv("C:/Users/User/Downloads/Irl et al_2015_J Ecol_Dryad.csv",skip=1,sep=";",dec=",")
names(d)<-gsub("\\.","",names(d))
d$northing<-d$LongitudeUTM/1000
d$easting<-d$LatitudeUTM/1000
d$Elevationm<-d$Elevationm/1000
plot(d[,c("SR","Elevationm","TCI")])

```

****

```{r,out.width="100%"}
library(sp)
library(mapview)
coordinates(d)<-~easting+northing
proj4string(d)<-"+proj=utm +zone=28 +ellps=WGS84 +datum=WGS84 +units=km +no_defs"
ds<-spTransform(d,CRS("+init=epsg:4326"))
mapviewOptions(basemaps = c("Esri.WorldImagery","Esri.WorldShadedRelief"))
mapview(ds,zcol="SR")
```

****

```{r}
fit<-glm(SR~Elevationm+I(Elevationm^2)+TCI,data=d@data,family=poisson)
summary(fit)
```

****

```{r}
library(visreg)
par(mfrow=c(1,2))
visreg(fit,scale="response",rug=FALSE)
```

****

```{r}
library(geoR)
v<-variog(coords=cbind(d$easting,d$northing),data=resid(fit),breaks=seq(0,10,by=0.5),max.dist=10)
plot(v, main="Empirical Variogram for Species Richness (SR)",type="b",xlab="Distance (km)",ylab="Semivariance") 
```

****

## INLA

### Approche bayésienne

****

Bayes' rule

$$P(A|B) = \frac{P(B|A)P(A)}{P(B)}$$

****

Lorsque appliquée aux modèles

$$P(\theta|data) = \frac{P(data|\theta)P(\theta)}{P(data)}$$
<br><br>
$data$: données
$\theta$: paramètres du modèle

### Priors

### LGM

### SPDE

SPDE veut dire **S**tochastic **P**artial **D**ifferential **E**quation

Cette approche se base entre-autres sur une discrétisation du Gaussian Random Field (GRF) par un Gaussian Markov Random Field (GMRF)

Utilise une fonction de Matérn pour capturer la dépendance entre les localisations.

##

```{r}
library(INLA)
m<-inla(SR~Elevationm+I(Elevationm^2)+TCI,data=d@data,family="poisson")
summary(m)
```

****

```{r}
m$summary.fixed[,c(1:3,5)]
cbind(summary(fit)$coef[,1:2],confint(fit))
```



# Un exemple de cas

## Cas

## Étapes

- **Mesh**: permet de créer une triangulation qui discrétise le GF
- **Projector Matrix**: permet de relier les localisations à la grille
- **SPDE**: permet détablir le lien le SPDE et la fonction Matérn
- **Spatial Field**: permet de créer le champs spatial
- **Stack**: permet d'intégrer les différents éléments
- **Formula**: formulation du modèle
- **Modèle**: permet de faire tourner le modèle

****

### Mesh

```{r,collapse=FALSE}
locs<-coordinates(d)
head(locs)
```

****

```{r,collapse=FALSE}
library(INLA)
hull<-inla.nonconvex.hull(locs,convex=-0.05)
mesh<-inla.mesh.2d(loc=locs,offset=c(0.5,5),max.edge=c(0.5,1.5),cutoff=0.5,boundary=hull)
```

****

```{r,collapse=FALSE}
plot(mesh,asp=1)
axis(1)
axis(2)
points(locs,col="red",pch=16)
```

****

### Projector Matrix

```{r,collapse=FALSE}
A<-inla.spde.make.A(mesh,locs)
```

****

### SPDE

```{r,collapse=FALSE}
prior.sd<-10
prior.range<-1
spde<-inla.spde2.pcmatern(mesh,alpha=2,prior.range=c(prior.range,0.5),prior.sigma=c(prior.sd,0.01))
```

****

### Spatial Field

```{r,collapse=FALSE}
s.index<-inla.spde.make.index(name="spatial",n.spde=spde$n.spde)
```

****

### Stack

```{r,collapse=FALSE}
v<-c("TCI","Elevationm")
vars<-d@data[,v]
stack<-inla.stack(data=list(SR=d$SR),A=list(A,1),effects=list(c(s.index,list(Intercept=1)),as.list(vars)),tag="est")
```

****

### Formula

```{r,collapse=FALSE}
model<-SR~-1+Intercept+Elevationm+I(Elevationm^2)+TCI+f(spatial,model=spde)
```

****

### Modèle

```{r,collapse=FALSE}
m<-inla(model,data=inla.stack.data(stack),control.predictor=list(A=inla.stack.A(stack)),control.compute=list(dic=TRUE,waic=TRUE),control.inla=list(int.strategy="eb"),family="poisson")
```

****

```{r,collapse=FALSE}
res<-inla.spde.result(m,"spatial",spde)
par(mfrow=c(2,1))
plot(res$marginals.range.nominal[[1]],
     type="l", main="Posterior density for range")
plot(inla.tmarginal(sqrt, res$marginals.variance.nominal[[1]]),
     type="l", main="Posterior density for sd")
```

****

```{r,include=FALSE,echo=FALSE}
#tmp = inla.tmarginal(function(x) exp(-x), m$internal.marginals.hyperpar[[2]]) 
#xvals = seq(0, 10, length.out=1000)
#plot(tmp, type = "l", xlab = "inverse range", ylab = "Density",xlim=range(xvals))
#lambda = -log(.5)/(1/prior.median.range); lines(xvals, 6*exp(-lambda*xvals), lty='dashed')
```

****

```{r,collapse=FALSE}
par(mfrow=c(2,2))
invisible(
	 lapply(names(m$marginals.fixed),function(i){
    p<-m$marginals.fixed[[i]]	
	   plot(p[,1],p[,2],type="l",xlab=i,ylab="density")
	   abline(v=0,lty=3)
  })
)
```

****

```{r,echo=FALSE,include=FALSE}
#library(inlabru)
#spde.posterior(m,"spatial",what="range")
```


```{r,collapse=FALSE}

library(fields)
library(viridisLite)

# https://haakonbakka.bitbucket.io/btopic108.html#92_plotting_the_spatial_mean_field


xlim<-range(d$easting)
ylim<-range(d$northing)

# - Can project from the mesh onto a 300x300 plotting grid 
proj<-inla.mesh.projector(mesh,xlim=xlim,ylim=ylim,dims=c(300,300))

# - Do the projection
field<-m$summary.random[['spatial']][['mean']]
field.proj<-inla.mesh.project(proj,field)


par(mar=c(2,2,2,2))
image.plot(list(x=proj$x,y=proj$y,z=field.proj),col=viridis(100),asp=1)  
axis(1)
axis(2)



```




```{r}
library(scales)
d<-read.table("C:/Users/User/Downloads/IrishPh/IrishPh.txt",header=TRUE)

d$Easting<-d$Easting/1000
d$Northing<-d$Northing/1000
d$Forested<-as.factor(d$Forested)

hist(d$pH)
plot(d$Easting,d$Northing,cex=rescale(d$pH,to=c(0,2)))


fit<-glm(pH~SDI+Altitude+Forested,data=d)
summary(fit)

library(visreg)
par(mfrow=c(1,2))
visreg(fit,scale="response",rug=FALSE)


library(geoR)
v<-variog(coords=cbind(d$Easting,d$Northing),data=resid(fit),breaks=seq(0,100,by=5),max.dist=100)
plot(v, main="Empirical Variogram for Species Richness (SR)",type="b",xlab="Distance (km)",ylab="Semivariance") 




d<-read.csv("https://raw.githubusercontent.com/frousseu/ECL749/master/data/frogs.csv",sep=";")
plot(d$easting,d$northing,col=d$pres.abs+1)

fit<-glm(pres.abs~1,family="binomial",data=d)

v<-variog(coords=cbind(d$easting,d$northing),data=resid(fit))#,breaks=seq(0,20,by=1),max.dist=20)
plot(v, main="Empirical Variogram for Species Richness (SR)",type="b",xlab="Distance (km)",ylab="Semivariance") 


```









# Exercice 1

# Exercice 2

# Liens utiles

## Forum R-INLA

## Livres en ligne

## Livres

## Articles importants


